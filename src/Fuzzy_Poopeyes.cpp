/*
 Name:		Fuzzy_Poopeyes.cpp
 Created:	1/29/2018 9:15:08 PM
 Author:	georgychen
 Editor:	http://www.visualmicro.com
*/

#include "Fuzzy_Poopeyes.h"
#include <Wire.h>
#include "Streaming_local.h"
#include "Adafruit_ZeroDMA_Local.h"
#include  "wiring_private.h" //pinPeripheral() function

//Include one of the eyes matrix files here. Just one.

#include "Eyes_UpperEyelid_128x64.h"
#include "Eyes_Pupil_64x64.h"
#include "Eyes_LowerEyelid_128x64.h"



FuzzyOLEDDriver* FuzzyOLEDDriver::fuzzyOLEDPointer = 0;

/*
		SERCOM	Arduion Pin
SDA		3			20
SCL		3			21


Alternate Wire is configured at:
SDA SERCOM1.0 PA16  SAM15x15 pin 21	Arduino pin 11
SCL SERCOM1.1 PA17  SAM15X15 pin 22 Arduino pin 13

*/
FuzzyOLEDDriver::FuzzyOLEDDriver()
{
	fuzzyOLEDPointer = this;
}

void FuzzyOLEDDriver::begin()
{
	
	Wire.begin();
	//Wire.setClock(1000000); //this method may be inaccurate

	//due to library bug, set correct I2C speed via registers
	sercom3.disableWIRE();											// Disable the I2C bus
	SERCOM3->I2CM.BAUD.bit.BAUD = 47972352 / (2 * 1000000) - 7;		// Set the correct I2C SCL frequency
	sercom3.enableWIRE();											// Restart the I2C bus

	//transfer speed and time
	/*timing issues
	Incorrect baud
	setClock	h-fill(2)
	1000000		33.982 ms
	2000000		23.835 ms
	2400000		22.526 ms
	3000000		20.642 ms
	Above		N/A			doesn't work

	I2C Corrected baud rate
	setClock	h-fill(2)		Fill-FPS	FPS(Draw)(2)	Visual Result				Note
	100000		204.333 ms		4.9			5				ery poor					Spec
	400000		57.472  ms		17.4		22				obvious un-smoothness		Spec
	800000		32.723  ms		30.6		43				ok-smooth					Off-Spec, over-clocked
	1000000		27.895  ms		35.4		54				smooth						Off-Spec, over-clocked
	1200000		24.950	ms		40.1		64				smooth						Off-Spec, over-clocked
	1600000		20.621  ms		48.5		85				erroneous					Off-Spec, over-clocked
	Above		N/A				--			--				doesn't work

	SSD1306 rated at 400k
	*/

	//memory usage and draweye() duration
	/*
	eyelid expanded, pupil non-expanded,

	bitmap			size		bytes	vertical expansion	sub-totol
	upper eyelid	128x64		1024	2048					3072
	upper eyelid	128x64		1024	2048					3072
	pupil			 64x64		512								512
	lower eyelid	128x64		1024	2048					3072
	lower eyelid	128x64		1024	2048					3072
	screen			128x64										1024

	total sram usage for two eyes:  13824 bytes (13.5k)

	duration = 1010us

	eyelid non-expanded, pupil non-expanded,
	bitmap			size		bytes
	upper eyelid	128x64		1024
	upper eyelid	128x64		1024
	pupil			 64x64		512
	lower eyelid	128x64		1024
	lower eyelid	128x64		1024
	screen			128x64		1024

	total sram usage for two eyes:  5632 bytes (5.5k)

	duration = 1520us

	*/
	
	sendCommand(DISPLAY_OFF);
	
	sendCommand(SET_DISPLAY_CLOCK_DIV);
	sendCommand(0x80);//default value

	sendCommand(SET_MULTIPLEX_RATIO);
	sendCommand(OLED_SCREEN_HEIGHT - 1);

	sendCommand(SET_DISPLAY_OFFSET);
	sendCommand(0x00);//default value

	sendCommand(SET_DISPLAY_START_LINE | 0x00);

	sendCommand(SET_CHARGE_PUMP); //enable charge pump 
	sendCommand(0x14); //Vcc generated by internal DC/DC circuit

	sendCommand(SET_INVERSE_DISPLAY); //Display is set inverse, easier for bitmap drawing

	sendCommand(SET_DISPLAY_ON_RESUME_RAM);

	sendCommand(SET_SEG_REMAPPED_TRUE); //column address 127 is mapped to SEG0, this changes the column direction

	sendCommand(SET_COM_SCAN_REMAPPED_TRUE);//This changes the page display direction

	sendCommand(SET_COM_PINS);
	sendCommand(0x12);

	sendCommand(SET_CONTRAST);
	sendCommand(255);

	sendCommand(SET_PRE_CHARGE_PERIOD);
	sendCommand(0xF1);

	sendCommand(SET_VCOMH_DESELECT_LEVEL);
	sendCommand(0x40);

	//Use horizontal mode
	sendCommand(SET_MEMORY_ADDRESS_MODE);
	sendCommand(HORIZONTAL_MODE);

	sendCommand(SET_PAGE_START_END_ADDRESS);
	sendCommand(0x00);
	sendCommand(0x07);
	sendCommand(SET_COLUMN_START_END_ADDRESS);
	sendCommand(0x00);
	sendCommand(0x7F);

	
	//fillHorizontal(0x00);//clear display ram using normal, non-DMA method

	fillHorizontal(0xFF);//clear display ram using normal, non-DMA method

	sendCommand(DISPLAY_ON);

	//Time usage comparing 8 bit operation vs. 32 bit operation :
	/*
	Time usage comparing 8 bit operation vs. 32 bit operation:
	8 bit mem copy x 1024 operations = 434 us.
	32 bit mem copy x 256 operations = 119 us.
	*/
	/*
	uint32_t timer = micros();
	for (uint16_t i = 0; i < 1024; i++)
	{
		unionScreenBuffer[1].buffer8[i] = unionScreenBuffer[0].buffer8[i];
	}
	uint32_t duration = micros() - timer;
	Serial << "8 bit mem copy x 1024 operations = " << duration << " us." << endl;

	timer = micros();
	for (uint16_t i = 0; i < 256; i++)
	{
		unionScreenBuffer[1].buffer32[i] = unionScreenBuffer[0].buffer32[i];
	}
	duration = micros() - timer;
	Serial << "32 bit mem copy x 256 operations = " << duration << " us." << endl;
	*/
	

	//Copy the bitmap array to related operating array.
	//The array names are assigned here. 
	setEyeArray(Eyes_UpperEyelid_128x64, Eyes_Pupil_64x64, Eyes_LowerEyelid_128x64);

	//draw the left eye
	drawEye(&unionScreenBuffer[0], &unionLeftUpperEyelidArray, &unionPupilArray, &unionLeftLowerEyelidArray, LEFT_EYE);
	//display the left eye using non-dma method
	writeBufferHorizontal(&unionScreenBuffer[0], LEFT_EYE);

	//draw the right eye
	drawEye(&unionScreenBuffer[1], &unionRightUpperEyelidArray, &unionPupilArray, &unionRightLowerEyelidArray, RIGHT_EYE);
	//display the right eye using non-dma method
	writeBufferHorizontal(&unionScreenBuffer[1], RIGHT_EYE);

	currentUpdatingDevice = LEFT_EYE;


	//setup the DMA transfer
	//Serial.println("Configuring DMA trigger");

	//default I2C for arduino zero is on SERCOM3
	myDMA.setTrigger(SERCOM3_DMAC_ID_TX);
	myDMA.setAction(DMA_TRIGGER_ACTON_BEAT);
	//Serial.print("Allocating DMA channel...");
	stat = myDMA.allocate();
	//myDMA.printStatus(stat);

	//Serial.println("Adding callback");
	// register_callback() can optionally take a second argument
	// (callback type), default is DMA_CALLBACK_TRANSFER_DONE
	myDMA.setCallback(fuzzyOLEDPointer->dma_callback);

	//Serial.println("Setting up transfer");
	descriptor = myDMA.addDescriptor(
		oledBuffer[currentUpdatingDevice],	// move data from here
		(void *)(&SERCOM3->I2CM.DATA.reg),	// to here (zero)
		OLED_BUFFER_SIZE,					// this many...
		DMA_BEAT_SIZE_BYTE,					// bytes/hword/words
		true,								// increment source addr?
		false);								// increment dest addr?

	writeBufferDMA(&unionScreenBuffer[currentUpdatingDevice], currentUpdatingDevice);

	startAutoMovement();
}

void FuzzyOLEDDriver::setDisplay(bool value)
{
	if (value == true)
	{
		sendCommand(DISPLAY_ON);
	}
	else
	{
		sendCommand(DISPLAY_OFF);
	}
}

void FuzzyOLEDDriver::setContrast(uint8_t value)
{
	sendCommand(SET_CONTRAST);
	sendCommand(value);
}

void FuzzyOLEDDriver::sendCommand(uint8_t command)
{
	sendCommand(command, command);
}

void FuzzyOLEDDriver::sendData(uint8_t data)
{
	sendData(data, data);
}

void FuzzyOLEDDriver::sendCommand(uint8_t command1, uint8_t command2)
{
	Wire.beginTransmission(_i2cAddress[LEFT_EYE]);
	Wire.write(CONTROL_BYTE_COMMAND);
	Wire.write(command1);
	Wire.endTransmission();

	#ifdef ENABLE_DEVICE_2
	Wire.beginTransmission(_i2cAddress[RIGHT_EYE]);
	Wire.write(CONTROL_BYTE_COMMAND);
	Wire.write(command2);
	Wire.endTransmission();
	#endif
}

void FuzzyOLEDDriver::sendData(uint8_t data1, uint8_t data2)
{
	Wire.beginTransmission(_i2cAddress[LEFT_EYE]);
	Wire.write(CONTROL_BYTE_DATA);
	Wire.write(data1);
	Wire.endTransmission();

	#ifdef ENABLE_DEVICE_2
	Wire.beginTransmission(_i2cAddress[RIGHT_EYE]);
	Wire.write(CONTROL_BYTE_DATA);
	Wire.write(data2);
	Wire.endTransmission();
	#endif
}

void FuzzyOLEDDriver::fillHorizontal(uint8_t value)
{
	uint32_t timer = micros();
	for (uint8_t page = 0; page < 8; page++)
	{
		//send data in batches of 32, due to the buffer size in the wire library is 64
		for (uint8_t batches = 0; batches < 4; batches++)
		{
			Wire.beginTransmission(_i2cAddress[LEFT_EYE]);
			Wire.write(CONTROL_BYTE_DATA);
			for (uint8_t column = 0; column < 32; column++)
			{
				Wire.write(value);
			}
			Wire.endTransmission();
		}
	}

	for (uint8_t page = 0; page < 8; page++)
	{
		//send data in batches of 32, due to the buffer size in the wire library is 64
		for (uint8_t batches = 0; batches < 4; batches++)
		{
			Wire.beginTransmission(_i2cAddress[RIGHT_EYE]);
			Wire.write(CONTROL_BYTE_DATA);
			for (uint8_t column = 0; column < 32; column++)
			{
				Wire.write(value);
			}
			Wire.endTransmission();
		}
	}
	uint32_t timeElapsed = micros() - timer;
	//Serial << "Fill Horizontal time elapsed = " << timeElapsed << " us." << endl;
}

void FuzzyOLEDDriver::dma_callback(Adafruit_ZeroDMA * dma)
{
	fuzzyOLEDPointer->transfer_is_done = true;
}

void FuzzyOLEDDriver::clear()
{
	//fill with 0xFF will clear the screen due to inverted display
	fillHorizontal(0xFF); 
}

void FuzzyOLEDDriver::writeBufferHorizontal(unionBufferType *buffer, EYE_INDEX eye)
{
	uint32_t timer = micros();

	if (eye == LEFT_EYE)
	{
		uint16_t index = 0;
		for (uint8_t page = 0; page < 8; page++)
		{
			//send data in batches of 32
			for (uint8_t batches = 0; batches < 4; batches++)
			{
				Wire.beginTransmission(_i2cAddress[LEFT_EYE]);
				Wire.write(CONTROL_BYTE_DATA);
				for (uint8_t column = 0; column < 32; column++)
				{
					Wire.write(buffer->buffer8[index]);
					index++;
				}
				Wire.endTransmission();
			}
		}
	}

	if (eye == RIGHT_EYE)
	{
		uint16_t index = 0;
		for (uint8_t page = 0; page < 8; page++)
		{
			//send data in batches of 32
			for (uint8_t batches = 0; batches < 4; batches++)
			{
				Wire.beginTransmission(_i2cAddress[RIGHT_EYE]);
				Wire.write(CONTROL_BYTE_DATA);
				for (uint8_t column = 0; column < 32; column++)
				{
					Wire.write(buffer->buffer8[index]);
					index++;
				}
				Wire.endTransmission();
			}
		}
	}

	uint32_t duration = micros() - timer;
	//Serial << "writeBufferHorizontal() duration = " << duration << " us." << endl;
}

void FuzzyOLEDDriver::writeBufferDMA(unionBufferType *buffer, EYE_INDEX eye)
{

	//uint32_t timer = micros();

	myDMA.changeDescriptor(descriptor, buffer);

	//Serial << "Starting transfer job for eye indix " << eye << endl;
	eyeDMAUpdatingTimer = micros();


	/*
	SERCOM3->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;		//Smart mode enable, not required using adafruit zero DMA library
	SERCOM3->I2CM.ADDR.reg |= SERCOM_I2CM_ADDR_LENEN;		//Automatic transfer length enable, not required using adafruit zero DMA library
	SERCOM3->I2CM.ADDR.reg |= SERCOM_I2CM_ADDR_LEN(255);	//Transaction lenth, 0 to 255, not required using adafruit zero DMA library
	*/

	//Starting a I2C transaction:
	SERCOM3->I2CM.ADDR.reg = (SERCOM3->I2CM.ADDR.reg &  (~SERCOM_I2CM_ADDR_ADDR_Msk)) | SERCOM_I2CM_ADDR_ADDR(_i2cAddress[eye] << 1 | I2C_WRITE);  //START condition and address(7 bit address + 1 r/w bit) is sent upon register write. 

	while (!(SERCOM3->I2CS.STATUS.reg & SERCOM_I2CM_STATUS_CLKHOLD)); //Wait until previous transmittion completed 

	SERCOM3->I2CM.DATA.reg = (CONTROL_BYTE_DATA);	//Send a control byte. This byte is to tell SSD1036 that following bytes are screen data bytes. Accessing DATA register auto-triggers read or write operation

	while (!(SERCOM3->I2CS.STATUS.reg & SERCOM_I2CM_STATUS_CLKHOLD)); //Wait until previous transmittion completed 

																	  // no need to manually trigger transfer, it starts up on its own.
	stat = myDMA.startJob();

	//uint32_t duration = micros() - timer;
	//Serial << "writeBuffer() duration = " << duration << " us." << endl;
}

void FuzzyOLEDDriver::setEyeArray(const unsigned char * _upperEyelidBitmapArray, const unsigned char * _pupilBitmapArray, const unsigned char * _lowerEyelidBitmapArray)
{
	//copy bitmap array to application array. 
	//bright and dark are stored in the two extra array items

	//Right eye is a direct copy
	//upper eyelid, upper out-of-bounds are dark, lower out-of-bounds are bright
	for (uint16_t arrayIndex = 0; arrayIndex < OLED_BUFFER_SIZE; arrayIndex++)
	{
		unionRightUpperEyelidArray.buffer8[arrayIndex] = _upperEyelidBitmapArray[arrayIndex];
	}
	unionRightUpperEyelidArray.buffer32[OLED_BUFFER_SIZE_32 + EOF_BRIGHT_INDEX_OFFSET - 1] = BRIGHT_32;
	unionRightUpperEyelidArray.buffer32[OLED_BUFFER_SIZE_32 + EOF_DARK_INDEX_OFFSET - 1] = DARK_32;

	//pupil, direct copy
	for (uint16_t arrayIndex = 0; arrayIndex < PUPIL_BUFFER_SIZE; arrayIndex++)
	{
		unionPupilArray.buffer8[arrayIndex] = _pupilBitmapArray[arrayIndex];
	}
	unionPupilArray.buffer8[PUPIL_BUFFER_SIZE + EOF_BRIGHT_INDEX_OFFSET - 1] = BRIGHT_BYTE;
	unionPupilArray.buffer8[PUPIL_BUFFER_SIZE + EOF_DARK_INDEX_OFFSET - 1] = DARK_BYTE;


	//lower eyelid, upper out-of-bounds values are white, lower out-of-bounds values are dark
	for (uint16_t arrayIndex = 0; arrayIndex < OLED_BUFFER_SIZE; arrayIndex++)
	{
		unionRightLowerEyelidArray.buffer8[arrayIndex] = _lowerEyelidBitmapArray[arrayIndex];
	}
	unionRightLowerEyelidArray.buffer32[OLED_BUFFER_SIZE_32 + EOF_BRIGHT_INDEX_OFFSET - 1] = BRIGHT_32;
	unionRightLowerEyelidArray.buffer32[OLED_BUFFER_SIZE_32 + EOF_DARK_INDEX_OFFSET - 1] = DARK_32;


	//Left eye is a mirror copy for upper and lower eyelid

	//upper eyelid, upper out-of-bounds are dark, lower out-of-bounds are bright
	for (uint16_t pageIndex = 0; pageIndex < OLED_SCREEN_PAGE; pageIndex++)
	{
		for (uint16_t columnIndex = 0; columnIndex < OLED_SCREEN_COLUMN; columnIndex++)
		{
			unionLeftUpperEyelidArray.buffer8[OLED_SCREEN_COLUMN - columnIndex - 1 + pageIndex*OLED_SCREEN_COLUMN] = _upperEyelidBitmapArray[columnIndex + pageIndex*OLED_SCREEN_COLUMN];
		}
	}
	unionLeftUpperEyelidArray.buffer32[OLED_BUFFER_SIZE_32 + EOF_BRIGHT_INDEX_OFFSET - 1] = BRIGHT_32;
	unionLeftUpperEyelidArray.buffer32[OLED_BUFFER_SIZE_32 + EOF_DARK_INDEX_OFFSET - 1] = DARK_32;

	//lower eyelid, upper out-of-bounds values are white, lower out-of-bounds values are dark
	for (uint16_t pageIndex = 0; pageIndex < OLED_SCREEN_PAGE; pageIndex++)
	{
		for (uint16_t columnIndex = 0; columnIndex < OLED_SCREEN_COLUMN; columnIndex++)
		{
			unionLeftLowerEyelidArray.buffer8[OLED_SCREEN_COLUMN - columnIndex - 1 + pageIndex*OLED_SCREEN_COLUMN] = _lowerEyelidBitmapArray[columnIndex + pageIndex*OLED_SCREEN_COLUMN];
		}
	}
	unionLeftLowerEyelidArray.buffer32[OLED_BUFFER_SIZE_32 + EOF_BRIGHT_INDEX_OFFSET - 1] = BRIGHT_32;
	unionLeftLowerEyelidArray.buffer32[OLED_BUFFER_SIZE_32 + EOF_DARK_INDEX_OFFSET - 1] = DARK_32;
}

void FuzzyOLEDDriver::drawEye(unionBufferType *screenBuffer, unionEyelidBitmapArrayType *upperEyelidArray, unionPupilBitmapArrayType *pupilArray, unionEyelidBitmapArrayType *lowerEyelidArray, EYE_INDEX eye)
{

	uint32_t timer = micros();
	//OLED Inverse mode: Bright = 0, Dark = 1;

	//fill screenBuffer with bright
	//memset(screenBuffer, BRIGHT, OLED_BUFFER_SIZE); //150 us

	//apply upperEyelidArray to screenBuffer
	/*
	Dark(1) override on default bright(0).
	Out of boundry:
	- upper part: fill with dark(1)
	- lower part: fill with bright(0)
	*/

	uint16_t screenColumn32;
	uint16_t screenPage;
	int16_t byteIndex32 = 0;
	uint32_t upperEyelidDataToWrite;
	uint8_t pupilDataToWrite;
	uint32_t lowerEyelidDataToWrite;
	int16_t upperEyelidYOffset; //0 = centered, non-offset
	int16_t lowerEyelidYOffset; //0 = centered, non-offset
	int16_t upperEyelidByte32IndexOffset; //used to get current data byte32 index
	int16_t lowerEyelidByte32IndexOffset; //used to get current data byte32 index
	int16_t pupilIndex32 = 0;
	int16_t PupilXPositionOffset = 0;
	int16_t PupilYPositionOffset = 0;

	if (eye == LEFT_EYE)
	{
		upperEyelidYOffset = -leftUpperEyelidPositionOffset - upperEyelidBlinkYOffsetDeltaLeft;
		lowerEyelidYOffset = -leftLowerEyelidPositionOffset;
		PupilXPositionOffset = leftPupilXPositionOffset;
		PupilYPositionOffset = leftPupilYPositionOffset;
	}
	else if (eye == RIGHT_EYE)
	{
		upperEyelidYOffset = -rightUpperEyelidPositionOffset - upperEyelidBlinkYOffsetDeltaRight;
		lowerEyelidYOffset = -rightLowerEyelidPositionOffset;
		PupilXPositionOffset = rightPupilXPositionOffset;
		PupilYPositionOffset = rightPupilYPositionOffset;
	}


	//upper eyelid calculation
	upperEyelidByte32IndexOffset = ((upperEyelidYOffset + 7) >> 3) << 5;
	uint16_t upperEyelidBitIndexOffset = 8 - upperEyelidYOffset & 0B00000111;
	uint16_t upperEyelidBitIndexOffsetPreviousPage = 8 - upperEyelidBitIndexOffset;

	/*
	Serial << "upperEyelidYOffset = " << upperEyelidYOffset;
	Serial << " upperEyelidByte32IndexOffset = " << upperEyelidByte32IndexOffset;
	Serial << " upperEyelidBitIndexOffset = " << upperEyelidBitIndexOffset;
	Serial << " upperEyelidBitIndexOffsetPreviousPage = " << upperEyelidBitIndexOffsetPreviousPage << endl;

	for (int16_t i = -64; i <= 64; i++)
	{
	upperEyelidYOffset = i;
	upperEyelidByte32IndexOffset = ((upperEyelidYOffset + 7) >> 3) << 5;
	upperEyelidBitIndexOffset = 8 - upperEyelidYOffset & 0B00000111;
	upperEyelidBitIndexOffsetPreviousPage = 8 - upperEyelidBitIndexOffset;
	Serial << "" << upperEyelidYOffset;
	Serial << "  " << upperEyelidByte32IndexOffset;
	Serial << "  " << upperEyelidBitIndexOffset;
	Serial << "  " << upperEyelidBitIndexOffsetPreviousPage << endl;
	}
	return;
	*/

	// display byte vertical operation target values
	/* display byte vertical operation target values
	************ bitmap moving down on the screen ************
	yOffset	indexOffset	bitOffset	previousBitOffset
	-11		-32			3			5
	-10		-32			2			6	==> bitmap moving down on the screen
	-9		-32			1			7
	-8		-32			0			8
	-7		0			7			1
	-6		0			6			2
	-5		0			5			3
	-4		0			4			4
	-3		0			3			5
	-2		0			2			6
	-1		0			1			7	current get LSB 7, previous get MSB 1
	0		0			0			8	current get all
	1		32			7			1	current (higher page) LSB 1, previous(current page) MSB 7
	2		32			6			2
	3		32			5			3
	4		32			4			4
	5		32			3			5	==> bitmap moving up on the screen
	6		32			2			6
	7		32			1			7
	8		32			0			8
	9		64			7			1
	10		64			6			2
	11		64			5			3
	yOffset	indexOffset	bitOffset	previousBitOffset
	************ bitmap moving up on the screen ************
	*/


	//pupil calculation
	//leftPupilXPositionOffset = 0;
	//leftPupilYPositionOffset = -1;

	int16_t pupilScreenStartingX = PUPIL_SIDE_MARGIN + PupilXPositionOffset;
	int16_t puiplScreenEndingX = pupilScreenStartingX + PUPIL_WIDTH - 1;
	int16_t pupilScreenStartingY = PUIIL_TOP_DOWN_MARGIN + PupilYPositionOffset;
	int16_t puiplScreenEndingY = pupilScreenStartingY + PUPIL_HEIGHT - 1;

	int16_t pupilArrayStartingX;
	int16_t pupilArrayEndingX;
	int16_t pupilArrayStartingY;
	int16_t pupilArrayEndingY;

	uint16_t pupilScreenStartingColumn;
	uint16_t pupilScreenEndingColumn;
	uint16_t pupilScreenStartingPage;
	uint16_t pupilScreenEndingPage;

	uint16_t pupilArrayStartingPage;
	uint16_t pupilArrayStartingColumn;

	uint16_t pupilScreenColumnCount;
	uint16_t pupilScreenPageCount;

	uint16_t pupilCurrentPageShift;
	uint16_t pupilOtherPageShift;
	int16_t pupilArrayOtherByteIndexOffset;

	bool pupilOnScreen = true;
	if (abs(PupilXPositionOffset) >= ((OLED_SCREEN_WIDTH + PUPIL_WIDTH) / 2)) pupilOnScreen = false;
	if (abs(PupilXPositionOffset) >= ((OLED_SCREEN_HEIGHT + PUPIL_HEIGHT) / 2)) pupilOnScreen = false;

	if (pupilOnScreen == true)
	{
		//calculate starting x,y position for screen and pupil array
		pupilScreenStartingX = constrain(pupilScreenStartingX, 0, OLED_SCREEN_WIDTH - 1);
		puiplScreenEndingX = constrain(puiplScreenEndingX, 0, OLED_SCREEN_WIDTH - 1);

		pupilScreenStartingY = constrain(pupilScreenStartingY, 0, OLED_SCREEN_HEIGHT - 1);
		puiplScreenEndingY = constrain(puiplScreenEndingY, 0, OLED_SCREEN_HEIGHT - 1);

		/*calculate array position
		desired input/output
		leftPupilXPositionOffset	pupilArrayStartingColumn
		0							0
		-32							0
		-33							1
		-95							63
		-96							N/A (pupilOnScreen == false)
		32							0
		95							0
		96							N/A (pupilOnScreen == false)
		*/


		pupilArrayStartingX = (PupilXPositionOffset + PUPIL_SIDE_MARGIN) >= 0 ? 0 : -(PupilXPositionOffset + PUPIL_SIDE_MARGIN);
		pupilArrayEndingX = (PupilXPositionOffset - PUPIL_SIDE_MARGIN) <= 0 ? (PUPIL_WIDTH - 1) : PUPIL_WIDTH - (PupilXPositionOffset - PUPIL_SIDE_MARGIN) - 1;
		//calculate pupilScreenStartingColumn32
		/*target values
		startingX	pupilScreenStartingColumn32
		0			0	(four bytes in one column32 data)
		1			0
		2			0
		3			0
		4			1
		5			1
		*/

		pupilArrayStartingY = (PupilYPositionOffset + PUIIL_TOP_DOWN_MARGIN) >= 0 ? 0 : -(PupilYPositionOffset + PUIIL_TOP_DOWN_MARGIN);
		pupilArrayEndingY = (PupilYPositionOffset - PUIIL_TOP_DOWN_MARGIN) <= 0 ? (PUPIL_HEIGHT - 1) : PUPIL_HEIGHT - (PupilYPositionOffset - PUIIL_TOP_DOWN_MARGIN) - 1;

		pupilArrayStartingPage = pupilArrayStartingY >> 3;
		pupilArrayStartingColumn = pupilArrayStartingX;

		pupilScreenStartingColumn = pupilScreenStartingX;
		pupilScreenEndingColumn = puiplScreenEndingX;


		//calculate screen starting page
		/*target values
		startingX	startingPage
		0			0
		1			0
		7			0
		8			1
		9			1
		15			1
		63			8
		64			N/A (pupilOnScreen == false)
		*/
		pupilScreenStartingPage = pupilScreenStartingY >> 3;
		pupilScreenEndingPage = puiplScreenEndingY >> 3;

		pupilScreenColumnCount = pupilScreenEndingColumn - pupilScreenStartingColumn + 1;
		pupilScreenPageCount = pupilScreenEndingPage - pupilScreenStartingPage + 1;


		if (PupilYPositionOffset % 8 != 0)
		{
			if (PupilYPositionOffset > 0)
			{
				pupilArrayOtherByteIndexOffset = -PUPIL_WIDTH;
				pupilCurrentPageShift = PupilYPositionOffset & 0B00000111;
				pupilOtherPageShift = 8 - pupilCurrentPageShift;
			}
			else
			{
				pupilArrayOtherByteIndexOffset = PUPIL_WIDTH;
				pupilCurrentPageShift = 8 - PupilYPositionOffset & 0B00000111;
				pupilOtherPageShift = 8 - pupilCurrentPageShift;
			}
		}
		else
		{
			pupilArrayOtherByteIndexOffset = 0;
			pupilCurrentPageShift = 0;
			pupilOtherPageShift = 0;
		}



	}

	//lower eyelid calculation

	lowerEyelidByte32IndexOffset = ((lowerEyelidYOffset + 7) >> 3) << 5;
	uint16_t lowerEyelidBitIndexOffset = 8 - lowerEyelidYOffset & 0B00000111;
	uint16_t lowerEyelidBitIndexOffsetPreviousPage = 8 - lowerEyelidBitIndexOffset;

	//#define PRINT_EACH_DATA
	for (screenPage = 0; screenPage < OLED_SCREEN_PAGE; screenPage++)
	{
		bool isLastPage = 0;
		//bool pupilWithinPage = false;
		//if (screenPage >= pupilScreenStartingPage && screenPage <= pupilScreenEndingPage)pupilWithinPage = true;
		//uint16_t pupilArrayIndexPageOffset32 = screenPage - pupilScreenStartingPage;
		if (screenPage == OLED_SCREEN_PAGE - 1)isLastPage = 1;
		//using 32bit union container
		for (screenColumn32 = 0; screenColumn32 < OLED_SCREEN_COLUMN_32; screenColumn32++)
		{
			//upper eyelid application
			upperEyelidDataToWrite = DARK_32; //all 0
											  //pupilDataToWrite = BRIGHT_32;
			lowerEyelidDataToWrite = BRIGHT_32;

#ifdef PRINT_EACH_DATA
			Serial << screenPage << " ";
			Serial << screenColumn << " ";
#endif //PRINT_EACH_DATA			

			//with two additions =>448us to 602us
			//with two additions + 4 ifs =>448us to 824us

			int16_t byteIndex32Switched = byteIndex32 + upperEyelidByte32IndexOffset;
			int16_t byteIndex32SwitchedPrevious = byteIndex32Switched - OLED_SCREEN_COLUMN_32;
			if (byteIndex32Switched < 0)byteIndex32Switched = OLED_BUFFER_SIZE_32 + EOF_DARK_INDEX_OFFSET - 1;
			else if (byteIndex32Switched > 255)byteIndex32Switched = OLED_BUFFER_SIZE_32 + EOF_BRIGHT_INDEX_OFFSET - 1;
			if (byteIndex32SwitchedPrevious < 0)byteIndex32SwitchedPrevious = OLED_BUFFER_SIZE_32 + EOF_DARK_INDEX_OFFSET - 1;
			else if (byteIndex32SwitchedPrevious > 255)byteIndex32SwitchedPrevious = OLED_BUFFER_SIZE_32 + EOF_BRIGHT_INDEX_OFFSET - 1;


			//Dark(1) override on default bright(0).
			upperEyelidDataToWrite =
				(
					//get the few dots from the row before current page
				(upperEyelidArray->buffer32[byteIndex32SwitchedPrevious])
					//shift the bits from previous page
					>> upperEyelidBitIndexOffsetPreviousPage
					)
				&
				//apply 32bit right shift mask to remove the high bits
				BIT_MASK_RIGHT_SHIFT_32[upperEyelidBitIndexOffsetPreviousPage]

				//add those two
				|

				(
					//get the few dots from current row(page)
				(upperEyelidArray->buffer32[byteIndex32Switched])
					//shift the bits from current page
					<< upperEyelidBitIndexOffset
					)
				&
				//apply 32bit left shift mask to remove the low bits
				BIT_MASK_LEFT_SHIFT_32[upperEyelidBitIndexOffset]
				;

			/*memory extinsive method
			//Dark(1) override on default bright(0).
			upperEyelidDataToWrite =
			(
			//get the few dots from the row before current page
			(upperEyelidArray->buffer32[byteIndex32 + upperEyelidExpandedByte32IndexOffset - OLED_SCREEN_COLUMN_32])
			//shift the bits from previous page
			>> upperEyelidExpandedBitIndexOffsetPreviousPage
			)
			&
			//apply 32bit right shift mask to remove the high bits
			BIT_MASK_RIGHT_SHIFT_32[upperEyelidExpandedBitIndexOffsetPreviousPage]

			//add those two
			|

			(
			//get the few dots from current row(page)
			(upperEyelidArray->buffer32[byteIndex32 + upperEyelidExpandedByte32IndexOffset])
			//shift the bits from current page
			<< upperEyelidExpandedBitIndexOffset
			)
			&
			//apply 32bit left shift mask to remove the low bits
			BIT_MASK_LEFT_SHIFT_32[upperEyelidExpandedBitIndexOffset]
			;


			*/


			//Serial << "byteIndex32+ OLED_BUFFER_SIZE_32" << (byteIndex32 +OLED_BUFFER_SIZE_32) << endl;


			//pupil application
			/*
			if (pupilWithinPage == true)
			{
			if (screenColumn32 >= pupilScreenStartingColumn32 && screenColumn32 <= pupilScreenEndingColumn32)
			{
			uint16_t pupilArrayIndexColumnOffset32 = screenColumn32 - pupilScreenStartingColumn32;

			pupilIndex32 = pupilArrayIndexPageOffset32 * 16 + pupilArrayIndexColumnOffset32;


			Serial << pupilIndex32 << " ";

			pupilDataToWrite = pupilArray->buffer32[pupilIndex32];

			//pupilDataToWrite = DARK_32;
			}
			}
			*/
			byteIndex32Switched = byteIndex32 + lowerEyelidByte32IndexOffset;
			byteIndex32SwitchedPrevious = byteIndex32Switched - OLED_SCREEN_COLUMN_32;
			if (byteIndex32Switched < 0)byteIndex32Switched = OLED_BUFFER_SIZE_32 + EOF_BRIGHT_INDEX_OFFSET - 1;
			else if (byteIndex32Switched > 255)byteIndex32Switched = OLED_BUFFER_SIZE_32 + EOF_DARK_INDEX_OFFSET - 1;
			if (byteIndex32SwitchedPrevious < 0)byteIndex32SwitchedPrevious = OLED_BUFFER_SIZE_32 + EOF_BRIGHT_INDEX_OFFSET - 1;
			else if (byteIndex32SwitchedPrevious > 255)byteIndex32SwitchedPrevious = OLED_BUFFER_SIZE_32 + EOF_DARK_INDEX_OFFSET - 1;


			//lower eyelid application
			lowerEyelidDataToWrite =
				(
					//get the few dots from the row before current page
				(lowerEyelidArray->buffer32[byteIndex32SwitchedPrevious])
					//shift the bits from previous page
					>> lowerEyelidBitIndexOffsetPreviousPage
					)
				&
				//apply 32bit right shift mask to remove the high bits
				BIT_MASK_RIGHT_SHIFT_32[lowerEyelidBitIndexOffsetPreviousPage]

				//add those two
				|

				(
					//get the few dots from current row(page)
				(lowerEyelidArray->buffer32[byteIndex32Switched])
					//shift the bits from current page
					<< lowerEyelidBitIndexOffset
					)
				&
				//apply 32bit left shift mask to remove the low bits
				BIT_MASK_LEFT_SHIFT_32[lowerEyelidBitIndexOffset]
				;

#ifdef PRINT_EACH_DATA
			Serial << "dataToWrite " << _HEX(upperEyelidDataToWrite) << " ";
			Serial << endl;
#endif //PRINT_EACH_DATA

			//upper eyelid and lower eyelid bitwise 'or'
			//so that any dark(1's) shows dark, both white(0's) shows white

			//upperEyelidDataToWrite = BRIGHT_32;
			//lowerEyelidDataToWrite = BRIGHT_32;
			screenBuffer->buffer32[byteIndex32] = upperEyelidDataToWrite | lowerEyelidDataToWrite;
			//screenBuffer->buffer32[byteIndex32] = upperEyelidDataToWrite;
			//screenBuffer->buffer32[byteIndex32] = lowerEyelidDataToWrite;
			byteIndex32++;
		}
	}

	//#define SERIAL_DEBUG_DRAWEYE

	//pupil application using 8 bit method (32bit too complicated)
	if (pupilOnScreen == true)
	{
		if (PupilYPositionOffset >= 0)
		{
			for (uint16_t screenPageOffset = 0; screenPageOffset < pupilScreenPageCount; screenPageOffset++)
			{
				int16_t pupilScreenPage = pupilScreenStartingPage + screenPageOffset;
				int16_t pupilArrayPage = pupilArrayStartingPage + screenPageOffset;

				for (uint16_t screenColumnOffset = 0; screenColumnOffset < pupilScreenColumnCount; screenColumnOffset++)
				{
					int16_t screenColumn = pupilScreenStartingColumn + screenColumnOffset;
					int16_t arrayColumn = pupilArrayStartingColumn + screenColumnOffset;

					int16_t screenArrayIndex = pupilScreenPage*OLED_SCREEN_WIDTH + screenColumn;
					int16_t pupilArrayIndex = pupilArrayPage * PUPIL_WIDTH + arrayColumn;

					int16_t pupilOtherArrayIndex = pupilArrayIndex + pupilArrayOtherByteIndexOffset;


					if (pupilOtherArrayIndex >> 9 != 0) pupilOtherArrayIndex = PUPIL_BUFFER_SIZE + EOF_BRIGHT_INDEX_OFFSET - 1; //this saves 75us (983us to 908us) from the next two lines of if()
																																//if (pupilOtherArrayIndex < 0) pupilOtherArrayIndex = PUPIL_BUFFER_SIZE + EOF_BRIGHT_INDEX_OFFSET - 1;
																																//if (pupilOtherArrayIndex >= PUPIL_BUFFER_SIZE) pupilOtherArrayIndex = PUPIL_BUFFER_SIZE + EOF_BRIGHT_INDEX_OFFSET - 1;

#ifdef SERIAL_DEBUG_DRAWEYE
					Serial << "pupilScreenPage =" << pupilScreenPage;
					Serial << " screenColumn =" << screenColumn;
					Serial << " pupilArrayPage =" << pupilArrayPage;
					Serial << " arrayColumn =" << arrayColumn;
					Serial << " pupilArrayIndex =" << pupilArrayIndex;
					Serial << " pupilOtherArrayIndex =" << pupilOtherArrayIndex;
					Serial << " pupilOtherArrayIndex op = " << (pupilOtherArrayIndex >> 9);
					Serial << endl;
#endif //SERIAL_DEBUG_DRAWEYE

					pupilDataToWrite =
						pupilArray->buffer8[pupilArrayIndex] << pupilCurrentPageShift
						|
						pupilArray->buffer8[pupilOtherArrayIndex] >> pupilOtherPageShift
						;
					/*
					move the (PupilYPositionOffset >= 0) outside of the for loop
					saves 300us time.
					(from 1308 to 1010us)

					if (PupilYPositionOffset >= 0)
					{
					pupilDataToWrite =
					pupilArray->buffer8[pupilArrayIndex] << pupilCurrentPageShift
					|
					pupilArray->buffer8[pupilOtherArrayIndex] >> pupilOtherPageShift
					;
					}
					else
					{
					pupilDataToWrite =
					pupilArray->buffer8[pupilArrayIndex] >> pupilCurrentPageShift
					|
					pupilArray->buffer8[pupilOtherArrayIndex] << pupilOtherPageShift
					;
					}
					*/
					screenBuffer->buffer8[screenArrayIndex] |= pupilDataToWrite; //use 'or', dark(1) on white(0)
				}
			}
		}
		else //(PupilYPositionOffset < 0)
		{
			for (uint16_t screenPageOffset = 0; screenPageOffset < pupilScreenPageCount; screenPageOffset++)
			{
				int16_t pupilScreenPage = pupilScreenStartingPage + screenPageOffset;
				int16_t pupilArrayPage = pupilArrayStartingPage + screenPageOffset;

				for (uint16_t screenColumnOffset = 0; screenColumnOffset < pupilScreenColumnCount; screenColumnOffset++)
				{
					int16_t screenColumn = pupilScreenStartingColumn + screenColumnOffset;
					int16_t arrayColumn = pupilArrayStartingColumn + screenColumnOffset;

					int16_t screenArrayIndex = pupilScreenPage*OLED_SCREEN_WIDTH + screenColumn;
					int16_t pupilArrayIndex = pupilArrayPage * PUPIL_WIDTH + arrayColumn;

					int16_t pupilOtherArrayIndex = pupilArrayIndex + pupilArrayOtherByteIndexOffset;


					if (pupilOtherArrayIndex >> 9 != 0) pupilOtherArrayIndex = PUPIL_BUFFER_SIZE + EOF_BRIGHT_INDEX_OFFSET - 1; //this saves 75us (983us to 908us) from the next two lines of if()
																																//if (pupilOtherArrayIndex < 0) pupilOtherArrayIndex = PUPIL_BUFFER_SIZE + EOF_BRIGHT_INDEX_OFFSET - 1;
																																//if (pupilOtherArrayIndex >= PUPIL_BUFFER_SIZE) pupilOtherArrayIndex = PUPIL_BUFFER_SIZE + EOF_BRIGHT_INDEX_OFFSET - 1;

#ifdef SERIAL_DEBUG_DRAWEYE
					Serial << "pupilScreenPage =" << pupilScreenPage;
					Serial << " screenColumn =" << screenColumn;
					Serial << " pupilArrayPage =" << pupilArrayPage;
					Serial << " arrayColumn =" << arrayColumn;
					Serial << " pupilArrayIndex =" << pupilArrayIndex;
					Serial << " pupilOtherArrayIndex =" << pupilOtherArrayIndex;
					Serial << " pupilOtherArrayIndex op = " << (pupilOtherArrayIndex >> 9);
					Serial << endl;
#endif //SERIAL_DEBUG_DRAWEYE

					pupilDataToWrite =
						pupilArray->buffer8[pupilArrayIndex] >> pupilCurrentPageShift
						|
						pupilArray->buffer8[pupilOtherArrayIndex] << pupilOtherPageShift
						;

					screenBuffer->buffer8[screenArrayIndex] |= pupilDataToWrite; //use 'or', dark(1) on white(0)
				}
			}
		}

	}


	uint32_t duration = micros() - timer;
	//Serial << "drawEye() duration = " << duration << " us." << endl;


#ifdef SERIAL_DEBUG_DRAWEYE
	Serial << " pupilOnScreen = " << pupilOnScreen << endl;
	if (pupilOnScreen == true)
	{
		Serial << " PupilXPositionOffset  = " << PupilXPositionOffset << endl;
		Serial << " PupilYPositionOffset  = " << PupilYPositionOffset << endl;
		Serial << endl;
		Serial << " pupilScreenStartingX  = " << pupilScreenStartingX << endl;
		Serial << " puiplScreenEndingX  = " << puiplScreenEndingX << endl;
		Serial << " pupilScreenStartingY  = " << pupilScreenStartingY << endl;
		Serial << " puiplScreenEndingY  = " << puiplScreenEndingY << endl;
		Serial << endl;
		Serial << " pupilArrayStartingX  = " << pupilArrayStartingX << endl;
		Serial << " pupilArrayEndingX  = " << pupilArrayEndingX << endl;
		Serial << " pupilArrayStartingY  = " << pupilArrayStartingY << endl;
		Serial << " pupilArrayEndingY  = " << pupilArrayEndingY << endl;
		Serial << endl;
		Serial << " pupilScreenStartingPage  = " << pupilScreenStartingPage << endl;
		Serial << " pupilScreenEndingPage  = " << pupilScreenEndingPage << endl;
		Serial << " pupilScreenStartingColumn  = " << pupilScreenStartingColumn << endl;
		Serial << " pupilScreenEndingColumn  = " << pupilScreenEndingColumn << endl;
		Serial << endl;
		Serial << " pupilCurrentPageShift  = " << pupilCurrentPageShift << endl;
		Serial << " pupilOtherPageShift  = " << pupilOtherPageShift << endl;
		//Serial << " pupilNextPage  = " << pupilNextPage << endl;
		Serial << endl;
		Serial << " pupilScreenPageCount  = " << pupilScreenPageCount << endl;
		Serial << " pupilScreenColumnCount  = " << pupilScreenColumnCount << endl;

	}
	Serial << endl;
#endif //SERIAL_DEBUG_DRAWEYE

}

void FuzzyOLEDDriver::testEye()
{
	leftPupilYPositionOffset = 0;
	int8_t delta = 1;
	while (false)
	{
		leftPupilYPositionOffset += delta;
		if (leftPupilYPositionOffset == 64) delta = -1;
		if (leftPupilYPositionOffset == -64) delta = +1;
		Serial << "offset = " << leftPupilYPositionOffset << " ";

		drawEye(&unionScreenBuffer[0], &unionLeftUpperEyelidArray, &unionPupilArray, &unionLeftLowerEyelidArray, LEFT_EYE);

		writeBufferHorizontal(&unionScreenBuffer[0], LEFT_EYE);
		; delay(0);
	}

	leftPupilXPositionOffset = 0;
	while (false)
	{
		leftPupilXPositionOffset += delta;
		if (leftPupilXPositionOffset == 96) delta = -1;
		if (leftPupilXPositionOffset == -96) delta = +1;
		Serial << "offset = " << leftPupilXPositionOffset << " ";

		drawEye(&unionScreenBuffer[0], &unionLeftUpperEyelidArray, &unionPupilArray, &unionLeftLowerEyelidArray, LEFT_EYE);

		writeBufferHorizontal(&unionScreenBuffer[0], LEFT_EYE);
		; delay(0);
	}

	leftUpperEyelidPositionOffset = 0;
	while (true)
	{
		leftUpperEyelidPositionOffset += delta;
		if (leftUpperEyelidPositionOffset == 64) delta = -1;
		if (leftUpperEyelidPositionOffset == -64) delta = +1;
		Serial << "offset = " << leftUpperEyelidPositionOffset << " ";

		drawEye(&unionScreenBuffer[0], &unionLeftUpperEyelidArray, &unionPupilArray, &unionLeftLowerEyelidArray, LEFT_EYE);

		writeBufferHorizontal(&unionScreenBuffer[0], LEFT_EYE);

	}
}

void FuzzyOLEDDriver::update()
{
	updateDMA();
	updateBlink();
	updatePosition();

	if (autoMovement == true)
	{
		randomBlink();
		randomPosition();
	}
}

void FuzzyOLEDDriver::blink()
{
	//Serial << "blink " <<  endl;
	blinkInProgress = true;
	upperEyelidDirectionIsDownward = true;
	blinkUpperEyelidMovementLength = DEFAULT_BLINK_MOVEMENT_LENGTH;
}

void FuzzyOLEDDriver::updateBlink()
{
	if (blinkInProgress == false) return;
	if (millis() - updateBlinkTimer < BLINK_UPDATE_INTERVAL) return;
	updateBlinkTimer = millis();
	if (upperEyelidDirectionIsDownward == true)
	{
		upperEyelidBlinkYOffsetDeltaLeft += DEFAULT_BLINK_STEP;
		upperEyelidBlinkYOffsetDeltaRight += DEFAULT_BLINK_STEP;
		if (upperEyelidBlinkYOffsetDeltaLeft > blinkUpperEyelidMovementLength)
		{
			upperEyelidDirectionIsDownward = false;
		}
	}
	else
	{
		upperEyelidBlinkYOffsetDeltaLeft -= DEFAULT_BLINK_STEP;
		upperEyelidBlinkYOffsetDeltaRight -= DEFAULT_BLINK_STEP;
		if (upperEyelidBlinkYOffsetDeltaLeft == 0) //one blink completed
		{
			blinkInProgress = false;
		}
	}
}

void FuzzyOLEDDriver::randomBlink()
{
	if (millis() - blinkTimer < blinkInterval) return;
	blinkInterval = random(BLINK_MIN_INTERVAL, BLINK_MAX_INTERVAL);
	blinkInProgress = true;
	upperEyelidDirectionIsDownward = true;
	blinkUpperEyelidMovementLength = DEFAULT_BLINK_MOVEMENT_LENGTH;
	blinkTimer = millis();
}

void FuzzyOLEDDriver::randomPosition()
{
	if (millis() - changePositionTimer < changePositionInterval) return;

	targetXLeft = random(-48, 48);
	targetYLeft = random(-32, 32);

	targetXRight = targetXLeft;
	targetYRight = targetYLeft;

	changePositionInterval = random(CHANGE_POSITION_MIN_INTERVAL, CHANGE_POSITION_BLINK_MAX_INTERVAL);
	changePositionTimer = millis();
}

void FuzzyOLEDDriver::updateDMA()
{
	if (transfer_is_done)
	{
		while (!(SERCOM3->I2CS.STATUS.reg & SERCOM_I2CM_STATUS_CLKHOLD)); //Wait until last byte transmittion completed

		SERCOM3->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(0x3); //Generate a STOP condition . We are done with this transaction
															   //Ending the I2C transaction
		eyeDMAUpdatingTimer = micros() - eyeDMAUpdatingTimer; // Elapsed time

															  //myDMA.printStatus(stat); // Results of start_transfer_job()

															  //Serial.print("Done! ");
															  //Serial.print(eyeDMAUpdatingTimer);
															  //Serial.println(" microseconds");
		transfer_is_done = false;

		fps++;

		if (millis() - fpsTimer   > 1000)
		{
			fpsTimer = millis();
			//Serial << "FPS = " << fps / 2 << endl;
			fps = 0;
		}

		//setup dam transfer on previous eye
		writeBufferDMA(&unionScreenBuffer[currentUpdatingDevice], currentUpdatingDevice);

		//change current device to next eye
		currentUpdatingDevice = (EYE_INDEX)((uint8_t)1 - (uint8_t)currentUpdatingDevice);

		//draw next eye while dma is writing on previous eye
		if (currentUpdatingDevice == LEFT_EYE)
		{
			drawEye(&unionScreenBuffer[LEFT_EYE], &unionLeftUpperEyelidArray, &unionPupilArray, &unionLeftLowerEyelidArray, LEFT_EYE);
		}
		else
		{
			drawEye(&unionScreenBuffer[RIGHT_EYE], &unionRightUpperEyelidArray, &unionPupilArray, &unionRightLowerEyelidArray, RIGHT_EYE);
		}
	}
}

void FuzzyOLEDDriver::updatePosition()
{
	if (millis() - updatePositionTimer < UPDATE_POSITION_INTERVAL) return;
	updatePositionTimer = millis();

	//update left pupil position
	if (leftPupilXPositionOffset > targetXLeft)
	{
		if (leftPupilXPositionOffset - targetXLeft > 10)
		{
			leftPupilXPositionOffset -= 2;
		}
		else
		{
			leftPupilXPositionOffset -= 1;
		}
	}
	if (leftPupilXPositionOffset < targetXLeft)
	{
		if (targetXLeft - leftPupilXPositionOffset   > 10)
		{
			leftPupilXPositionOffset += 2;
		}
		else
		{
			leftPupilXPositionOffset += 1;
		}
	}
	if (leftPupilYPositionOffset > targetYLeft)
	{
		leftPupilYPositionOffset--;
		if (autoMovement == true)
		{
			//change eyelid position with pupil position
			leftUpperEyelidPositionOffsetTarget = leftPupilYPositionOffset / EYELID_MOVEMENT_DIVIDER;
			leftLowerEyelidPositionOffsetTarget = leftPupilYPositionOffset / EYELID_MOVEMENT_DIVIDER;
		}
		else
		{

		}
	}
	if (leftPupilYPositionOffset < targetYLeft)
	{
		leftPupilYPositionOffset++;
		if (autoMovement == true)
		{
			//change eyelid position with pupil position
			leftUpperEyelidPositionOffsetTarget = leftPupilYPositionOffset / EYELID_MOVEMENT_DIVIDER;
			leftLowerEyelidPositionOffsetTarget = leftPupilYPositionOffset / EYELID_MOVEMENT_DIVIDER;
		}
		else
		{

		}
	}

	//update left eyelid position
	if (leftUpperEyelidPositionOffset > leftUpperEyelidPositionOffsetTarget) leftUpperEyelidPositionOffset--;
	if (leftUpperEyelidPositionOffset < leftUpperEyelidPositionOffsetTarget) leftUpperEyelidPositionOffset++;
	if (leftLowerEyelidPositionOffset > leftLowerEyelidPositionOffsetTarget) leftLowerEyelidPositionOffset--;
	if (leftLowerEyelidPositionOffset < leftLowerEyelidPositionOffsetTarget) leftLowerEyelidPositionOffset++;


	//update right pupil position
	if (rightPupilXPositionOffset > targetXRight)
	{
		if (rightPupilXPositionOffset - targetXRight > 10)
		{
			rightPupilXPositionOffset -= 2;
		}
		else
		{
			rightPupilXPositionOffset -= 1;
		}
	}
	if (rightPupilXPositionOffset < targetXRight)
	{
		if (targetXRight - rightPupilXPositionOffset   > 10)
		{
			rightPupilXPositionOffset += 2;
		}
		else
		{
			rightPupilXPositionOffset += 1;
		}
	} 
	if (rightPupilYPositionOffset > targetYRight)
	{
		rightPupilYPositionOffset--;
		if (autoMovement == true)
		{
			//change eyelid position with pupil position
			rightUpperEyelidPositionOffsetTarget = rightPupilYPositionOffset / EYELID_MOVEMENT_DIVIDER;
			rightLowerEyelidPositionOffsetTarget = rightPupilYPositionOffset / EYELID_MOVEMENT_DIVIDER;
		}
		else
		{

		}
	}
	if (rightPupilYPositionOffset < targetYRight)
	{
		rightPupilYPositionOffset++;
		if (autoMovement == true)
		{
			//change eyelid position with pupil position
			rightUpperEyelidPositionOffsetTarget = rightPupilYPositionOffset / EYELID_MOVEMENT_DIVIDER;
			rightLowerEyelidPositionOffsetTarget = rightPupilYPositionOffset / EYELID_MOVEMENT_DIVIDER;
		}
		else
		{

		}
	}

	//update right eyelid position
	if (rightUpperEyelidPositionOffset > rightUpperEyelidPositionOffsetTarget) rightUpperEyelidPositionOffset--;
	if (rightUpperEyelidPositionOffset < rightUpperEyelidPositionOffsetTarget) rightUpperEyelidPositionOffset++;
	if (rightLowerEyelidPositionOffset > rightLowerEyelidPositionOffsetTarget) rightLowerEyelidPositionOffset--;
	if (rightLowerEyelidPositionOffset < rightLowerEyelidPositionOffsetTarget) rightLowerEyelidPositionOffset++;

}

void FuzzyOLEDDriver::startAutoMovement()
{
	autoMovement = true;
}

void FuzzyOLEDDriver::stopAutoMovement()
{
	autoMovement = false;
}

void FuzzyOLEDDriver::setEyeTargetPosition(int16_t PupilX, int16_t PupilY, int16_t UpperEyelid, int16_t LowerEyelid, EYE_INDEX eye)
{
	if (eye == LEFT_EYE)
	{
		targetXLeft = PupilX;
		targetYLeft = PupilY;
		leftUpperEyelidPositionOffsetTarget = UpperEyelid;
		leftLowerEyelidPositionOffsetTarget = LowerEyelid;
	}
	else if (eye == RIGHT_EYE)
	{
		targetXRight = PupilX;
		targetYRight = PupilY;
		rightUpperEyelidPositionOffsetTarget = UpperEyelid;
		rightLowerEyelidPositionOffsetTarget = LowerEyelid;
	}

	
}

/*pointer used to attach TC5 interrupt*/
FuzzyDACAudio* _audioInstancePointer;

FuzzyDACAudio::FuzzyDACAudio()
{
	_audioInstancePointer = this;
}

void FuzzyDACAudio::begin()
{
	//configure the dac
	pinMode(A0, OUTPUT);
	analogWriteResolution(8);
	analogWrite(A0, DAC_8_NEUTRAL);

	//configure the sound arrays
	arrayMetadata[0]._HuffDict = HuffDict1;
	arrayMetadata[0]._SoundDataBits = SoundDataBits1;
	arrayMetadata[0]._SoundData = SoundData1;

	arrayMetadata[1]._HuffDict = HuffDict2;
	arrayMetadata[1]._SoundDataBits = SoundDataBits2;
	arrayMetadata[1]._SoundData = SoundData2;

	arrayMetadata[2]._HuffDict = HuffDict3;
	arrayMetadata[2]._SoundDataBits = SoundDataBits3;
	arrayMetadata[2]._SoundData = SoundData3;

	arrayMetadata[3]._HuffDict = HuffDict4;
	arrayMetadata[3]._SoundDataBits = SoundDataBits4;
	arrayMetadata[3]._SoundData = SoundData4;

	arrayMetadata[4]._HuffDict = HuffDict5;
	arrayMetadata[4]._SoundDataBits = SoundDataBits5;
	arrayMetadata[4]._SoundData = SoundData5;

	arrayMetadata[5]._HuffDict = HuffDict6;
	arrayMetadata[5]._SoundDataBits = SoundDataBits6;
	arrayMetadata[5]._SoundData = SoundData6;

	arrayMetadata[6]._HuffDict = HuffDict7;
	arrayMetadata[6]._SoundDataBits = SoundDataBits7;
	arrayMetadata[6]._SoundData = SoundData7;

	arrayMetadata[7]._HuffDict = HuffDict8;
	arrayMetadata[7]._SoundDataBits = SoundDataBits8;
	arrayMetadata[7]._SoundData = SoundData8;

	arrayMetadata[8]._HuffDict = HuffDict9;
	arrayMetadata[8]._SoundDataBits = SoundDataBits9;
	arrayMetadata[8]._SoundData = SoundData9;

	arrayMetadata[9]._HuffDict = HuffDict10;
	arrayMetadata[9]._SoundDataBits = SoundDataBits10;
	arrayMetadata[9]._SoundData = SoundData10;

	//active 8002D
	pinMode(SHUTDOWN_PIN, OUTPUT);
	setAmplifier(OFF);
	

	//configure the TC
	tcConfigure(_sampleRate);

}

void FuzzyDACAudio::tcConfigure(uint32_t sampleRate)
{
	// Enable GCLK for TC4 and TC5 (timer counter input clock)
	GCLK->CLKCTRL.reg = (uint16_t)(GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(GCM_TC4_TC5));
	while (GCLK->STATUS.bit.SYNCBUSY);

	tcReset();

	// Set Timer counter Mode to 16 bits
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_MODE_COUNT16;

	// Set TC5 mode as match frequency
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_WAVEGEN_MFRQ;

	//set prescaler
	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_PRESCALER_DIV1;

	//setup the count value
	TC5->COUNT16.CC[0].reg = (uint16_t)(SystemCoreClock / sampleRate - 1);
	while (tcIsSyncing());

	//SERIAL_OBJECT << "COUNT16.CC[0].reg = " << TC5->COUNT16.CC[0].reg << endl;

	// Configure interrupt request
	NVIC_DisableIRQ(TC5_IRQn);
	NVIC_ClearPendingIRQ(TC5_IRQn);
	NVIC_SetPriority(TC5_IRQn, 0);
	NVIC_EnableIRQ(TC5_IRQn);

	// Enable the TC5 interrupt request
	TC5->COUNT16.INTENSET.bit.MC0 = 1;
	while (tcIsSyncing());
}

void FuzzyDACAudio::play8BitArray(const uint8_t* arrayName, uint32_t arraySize)
{
	if (__isPlaying == true)return;
	__isPlaying = true;
	__nowPlayingSampleIndex = 0;
	__arraySize = arraySize;
	__arrayName = arrayName;
	//SERIAL_OBJECT << "array address = " << (uint32_t)__arrayName << endl;
	//SERIAL_OBJECT << "Size of array = " << arraySize << endl;

	tcStartCounter();

}

void FuzzyDACAudio::playHuffArrayBlocking(uint8_t trackIndex)
{
	if (trackIndex >= NUMBER_OF_SOUND_TRACKS) return;
	if (__isPlaying == true)return;
	__isPlaying = true;

	setAmplifier(ON);

	//setup the values and array pointers 
	g_stat.samplePosition = 0;
	g_stat.currentPCM = 0;
	_HuffDict = arrayMetadata[trackIndex]._HuffDict;
	_SoundDataBits = arrayMetadata[trackIndex]._SoundDataBits;
	_SoundData = arrayMetadata[trackIndex]._SoundData;

	tcStartCounter();
	while (isPlaying());

	//reset the sample rate to default value
	TC5->COUNT16.CC[0].reg = (uint16_t)(SystemCoreClock / _sampleRate - 1);
	while (tcIsSyncing());

	setAmplifier(OFF);
}

void FuzzyDACAudio::playHuffArrayBlocking(uint8_t trackIndex, uint16_t sampleRate)
{
	//setup the new sample rate
	TC5->COUNT16.CC[0].reg = (uint16_t)(SystemCoreClock / sampleRate - 1);
	while (tcIsSyncing());

	playHuffArrayBlocking(trackIndex);
}

void FuzzyDACAudio::tcReset()
{
	/*
	Reset TCx
	All registers in the TC, except DBGCTRL, will be reset to their initial state,
	and the TC will be disabled.
	The TC should be disabled before the TC is reset in order to avoid undefined behavior.
	*/

	tcDisable();
	TC5->COUNT16.CTRLA.reg = TC_CTRLA_SWRST;
	while (tcIsSyncing());
	while (TC5->COUNT16.CTRLA.bit.SWRST);
}

void FuzzyDACAudio::tcDisable()
{
	// Disable TC5
	TC5->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
	while (tcIsSyncing());
}

bool FuzzyDACAudio::tcIsSyncing()
{
	return TC5->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;
}

void FuzzyDACAudio::tcStartCounter()
{
	// Enable TC

	TC5->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
	while (tcIsSyncing());
}

void FuzzyDACAudio::interruptHandler(void)
{
	loadSample();

	/*
	if (__nowPlayingSampleIndex < __arraySize)
	{
	//SERIAL_OBJECT << __arrayName[__nowPlayingSampleIndex];
	analogWrite(A0, __arrayName[__nowPlayingSampleIndex]);
	__nowPlayingSampleIndex++;
	}
	else
	{
	// Disable TC5
	tcDisable();
	__isPlaying = false;
	analogWrite(A0, DAC_8_NEUTRAL);
	}
	*/
	// Clear the interrupt
	TC5->COUNT16.INTFLAG.bit.MC0 = 1;
}

bool FuzzyDACAudio::isPlaying()
{
	return __isPlaying;
}

// Get one bit from sound data
inline int FuzzyDACAudio::_get_bit(uint_fast32_t pos, boolean autoLoadOnBit0) {
	const auto bitPosition = pos & 7;
	static uint_fast8_t bit;
	if (!autoLoadOnBit0 || !bitPosition) {
		// read indexed byte from Flash memory
		//bit = pgm_read_byte(&SoundData[pos >> 3]);
		bit = _SoundData[pos >> 3];
	}
	// extract the indexed bit
	return (bit >> (7 - bitPosition)) & 1;
}

// Decode bit stream using Huffman codes
int_fast16_t FuzzyDACAudio::_decode_huff(uint_fast32_t &pos, int_fast16_t const *huffDict) {
	auto p = pos;
	do {
		const auto b = _get_bit(p++, true);
		if (b) {
			const auto offs = *huffDict;
			huffDict += offs ? offs + 1 : 2;
		}
	} while (*(huffDict++));
	pos = p;
	return *huffDict;
}

// This is called at sample rate to load the next sample.
void FuzzyDACAudio::loadSample()
{
	auto samplePosition = g_stat.samplePosition;

	// At end of sample, restart from zero, looping the sound.
	// ------
	// MIC: Don't forget to reset current amplitude, Thomas. :)
	// Forgetting to reset amplitude will cause a positive feedback, which displays as a deterioration in playback.
	// The time before playback failure depends on the last sample value.
	if (samplePosition >= _SoundDataBits) {
		//SERIAL_OBJECT << "samplePosition = " << samplePosition << endl;
		samplePosition = 0;
		g_stat.currentPCM = 0;

		// Disable TC5
		tcDisable();
		__isPlaying = false;
		analogWrite(A0, DAC_8_NEUTRAL);
	}

	// MIC: The differential series Dif[N+1] := sbytes[N+1] - sbytes[N], and Dif[0] = sbytes[0].
	// Has to be sint16, since each element is computed by subtraction between 2 sint8s.
	auto differential = _decode_huff(samplePosition, _HuffDict);
	g_stat.currentPCM += differential;

	// Set 16-bit PWM register with sample value
	//OCR1A = constrain(g_stat.currentPCM + (1 << (SampleBits - 1)), 0, (1 << SampleBits) - 1);

	uint16_t sample = constrain(g_stat.currentPCM + (1 << (SampleBits - 1)), 0, (1 << SampleBits) - 1);

	//SERIAL_OBJECT << "sample = " << sample << endl;

	const uint16_t dev = 120;
	sample = constrain(sample, DAC_8_NEUTRAL - dev, DAC_8_NEUTRAL + dev);
	sample = map(sample, DAC_8_NEUTRAL - dev, DAC_8_NEUTRAL + dev, 0, 255);


	//output the value to DAC
	analogWrite(A0, sample);

	g_stat.samplePosition = samplePosition;
}

#ifdef __cplusplus
extern "C" {
#endif

	void TC5_Handler(void)
	{
		//attach the TC5 interrupt handler to the instance
		_audioInstancePointer->interruptHandler();
	}


#ifdef __cplusplus
}
#endif

void FuzzyDACAudio::setAmplifier(bool status)
{
	digitalWrite(SHUTDOWN_PIN, !status); 
}